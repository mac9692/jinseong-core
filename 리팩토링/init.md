# REFACTORING - 마틴 파울러
## 리팩터링의 정의
```
리팩터링이란 용어는 명사로도 쓸 수 있고, 동사로도 쓸 수 있다.
리팩터링[명사] : 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법. (예 : 함수 추출하기, 조건부 로직을 다형성으로 바꾸기)
리팩터링[동사] : 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.
예를 들어 두 용어를 한 문장에 담으면 '앞으로 몇 시간은 리팩터링할 것 같은데 그 사이 적용하는 리팩터링은 수십 가지나 될 거 같다.'

리팩터링은 결국 동작을 보존하는 작은 단계를 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다.
개별 리팩터링은 그 자체로 아주 작을 수도 있고, 작은 단계 여러 개가 합쳐진 모습일 수도 있다.
따라서 리팩터링하는 동안에는 코드가 항상 정상 작동히기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.

누군가 '리팩터링하다가 코드가 깨져서 며칠이나 고생했다' 라고 한다면, 십중팔구 리팩터링한 것이 아니다.

리팩터링은 성능 최적화와 비슷하다.
둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다. 단지 목적이 다를 뿐이다.
리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 프로그램 성능은 좋아질 수도, 나빠질 수도 있다.
반면 성능 최적화는 오로지 속도 개선에만 신경 쓴다. 그래서 목표 성능에 반드시 도달해야 한다면 코드는 다루기에 더 어렵게 바뀔 수도 있음을 각오해야 한다.
```

## 리팩터링이란
```
리팩터링은 겉으로 드러나는 코드의 기능(겉보기 동작)은 바꾸지 않으면서 내부 구조를 개선하는 방식으로 소프트웨어 시스템을 수정하는 과정이다.
버그가 생길 가능성을 최소로 줄이면서 코드를 정리하는 정제된 방법이다.
요컨대, 리팩터링한다는 것은 코드를 작성하고 난 뒤에 설계를 개선하는 일이다.
코딩 후 설계 개선이라니 정말 이상한 말이다.
우리가 예전부터 따르던 소프트웨어 개발 방법은 설계부터 하고 코드를 작성하는 식이다.
좋은 설계가 우선되어야 하고 코딩은 그 다음이다.
하지만 시간이 흐르면서 코드는 수정되고 시스템의 무결성, 즉 설계에 맞춘 구조는 점차 뒤죽박죽이 되어간다.
공학에 가깝던 코딩 작업은 서서히 해킹에 가까워진다.
이 과정을 반대로 한 것이 리팩터링이다. 리팩터링을 하면 잘못된 설계나 심지어 엉망인 설계를 가져다가 체계적으로 설계된 코드로 탈바꿈할 수 있다.
리팩터링의 각 단계는 간단하다 못해 지나칠 정도로 단순하다. 하지만 이런 사소한 수정도 누적되면 설계가 놀랍도록 개선된다.
소프트웨어가 부식된다는 개념의 정반대가 바로 리팩터링이다.
리팩터링을 하면 일의 균형이 바뀐다. 처음부터 완벽한 설계를 갖추기보다는 개발을 진행하면서 지속적으로 설계한다.
시스템을 구축하는 과정에서 더 나은 설계가 무엇인지 배우게 된다.
그 결과, 개발의 시작부터 끝날 떄까지 프로그램은 줄곧 우수한 설계를 유지한다.
```

## 리팩터링하는 이유
```
리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 절대 아니다.
하지만 코드를 건강한 상태로 유지하는 데 도와주는 약임은 분명하다.

1. 리팩터링하면 소프트웨어 설계가 좋아진다.
2. 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
3. 리팩터링하면 버그를 쉽게 찾을 수 있다.
4. 리팩터링하면 프로그래밍 속도를 높일 수 있다.
```

## 리팩터링 진행 단계
```
1. 테스트 코드 작성
```

## 테스트 코드 작성
```
그냥 리팩터링하면 되지 않을까? 하지만 리팩터링에도 위험이 따른다.
리팩터링이란 코드를 수정하는 것이고, 그 과정에서 미묘한 버그가 생길 수 있다.
잘못 수행하면 오히려 며칠 혹은 몇 주간의 시간과 노력이 수포로 돌아갈 수 있다.
제대로 된 연습없이 즉흥적으로 실시하는 리팩터링은 더욱 위험하다.
코드를 분석하다가 새롭게 수정할 부분을 발견하면 즉흥적으로 더 깊이 파기 시작하는 사람이 많은데,
그럴수록 수정할 부분이 더 많아져 마침내 헤어날 수 없는 구렁텅이에 빠지게 된다.
자기 무덤을 파는 실수를 하지 않으려면 리팩터링을 반드시 계획적이며 체계적으로 해야 한다.
```

## 코드에서 나는 악취
```
1. 기이한 이름
코드는 단순하고 명료하게 작성해야 한다.
코드를 명료하게 표현하는 데 가장 중요한 요소 하나는 바로 '이름'이다.
그래서 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 이름을 지어야 한다.
이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다.
이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다.
마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다.
그래서 혼란스러운 이름을 잘 정리하다 보면 코드가 훨씬 간결해질 때가 많다.
2. 중복 코드
똑같은 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.
코드가 중복되면 각각을 볼 때마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다.
그 중 하나를 변경할 때는 다른 비슷한 코드들도 모두 살펴보고 적절히 수정해야 한다.
3. 긴 함수
짧은 함수들로 구성된 코드베이스를 얼핏 훑으면 연산하는 부분이 하나도 없어보인다.
코드가 끝없이 위임하는 방식으로 작성되어 있기 때문이다.
간접 호출의 효과, 즉 코드를 이해하고 공유하고 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.
프로그래밍 초창기부터 사람들은 함수가 길수록 이해하기 어렵다는 사실을 깨달았다. 예전 언어는 서브루틴을 호출하는 비용이 컸기 때문에 짧은 함수를 꺼렸다.
하지만 요즘 언어는 프로세스 안에서의 함수 호출 비용을 거의 없애버렸다.
물론 코드를 읽는 사람 입장에서는 함수가 하는 일을 파악하기 위해 왔다갔다 해야 하므로 여전히 부담이 된다.
짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.
그러기 위해서는 보다 적극적으로 함수를 쪼개야 한다. 우리는 주석을 달아야 할 만한 부분은 무조건 함수로 만든다.
그 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다.
4. 긴 매개변수 목록
예전에는 함수에 필요한 것들을 모조리 매개변수로 전달하라고 배웠다.
그래야 암적 존재인 전역 데이터가 늘어나는 사태를 막을 수 있기 때문에 그 시절에는 합리적인 방식이었다.
하지만 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많았다.
클래스는 매개변수 목록을 줄이는 데 효과적인 수단이기도 하다.
특히 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때 유용하다.
5. 전역 데이터
전역 데이터는 우리가 겪을 수 있는 악취 중 가장 지독한 축에 속한다.
전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다.
전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱클톤에서도 같은 문제가 발생한다.
이를 방지하기 위해 변수 캡슐화하기 기법을 사용한다.
이런 데이터를 함수로 감싸는 것 만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.
더 나아가 접근자 함수들은 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다.
전역 데이터가 가변이라면 특히나 다루기 까다롭다. 프로그램이 구동된 후에 값이 바뀌지 않는다고 보장할 수 있는 전역 데이터는 그나마 안전한 편이다.
파라켈수스가 말하길 '무엇이든 많이 복용하면 독이 될 수 있다'라고 했다.
전역 데이터도 조금뿐이라면 감당할 수 있겠지만, 많아지면 걷잡을 수 없게 된다. 우리는 전역 데이터가 아주 조금만 있더라도 캡슐화하는 편이다.
그래야 소프트웨어가 진화하는 데 따른 변화에 대처할 수 있다.
6. 가변 데이터
7. 뒤엉킨 변경
8. 산탄총 수술
9. 기능 편애
10. 데이터 뭉치
11. 기본형 집착
12. 반복되는 switch 문
13. 반복문
14. 성의 없는 요소
15. 추측성 일반화
16. 임시 필드
17. 메시지 체인
18. 중개자
19. 내부자 거래
20. 거대한 클래스
21. 서로 다른 인터페이스의 대안 클래스들
22. 데이터 클래스
23. 상속 포기
24. 주석
주석을 달면 안 된다고 말하려는 게 아니다.
주석은 악취가 아닌 향기를 입힌다. 문제는 주석을 탈취제처럼 사용하는 데 있다.
주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 의외로 많다.
실제로 악취가 너무 심해서 리팩터링으로 냄새를 걷어내고 봤더니, 상당량의 주석이 애초에 코드만 제대로 작성했다면 필요 없을 군더더기였던 적이 많았다.
주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.
주석은 현재 진행 상황뿐만 아니라 확실하지 않은 부분에 남긴다.
코드를 지금처럼 작성한 이유를 설명하는 용도로 달 수도 있다. 이런 정보는 나중에 코드를 수정해야 할 프로그래머에게 도움될 것이다.
```

